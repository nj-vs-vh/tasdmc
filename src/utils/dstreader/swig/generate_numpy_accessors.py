"""Generate custom numpy accessors for array struct fields

Basic idea is, if we want to access a struct like this from Python, we are out of luck
because SWIG-generated accessor get_structname_fieldname will return only a pointer to the
start of the array and lose all info about its size.

>>> typedef struct {
>>>     ...
>>>     fieldtype fieldname[size1][size2];
>>>     ...
>>> } structtype;
... 
>>> // global struct instance
>>> extern structtype structname;

If we, however, create custom copying accessor that accepts target array as argument (argout),
we can wrap it with SWIG's typemaps, particularly make it actually return numpy array containing
a copy of the data.

 |
 V

>>> %apply ( fieldtype ARGOUT_ARRAY2[ANY][ANY] ) { (fieldtype target[ANY][ANY]) };
...
>>> void get_structname_fieldname(fieldtype target[size1][size2]) {
>>>     memcpy(target, structname.fieldname, sizeof(structname.fieldname) * sizeof(fieldtype));
>>> }

This way we can then call this function from Python like this:

>>> arr = get_structname_fieldname()  # arr is 2D numpy ndarray
"""

import argparse
import re
from pathlib import Path
from typing import Tuple


def generate_accesor_func(
    field_type: str, field_name: str, field_sizes: str, ndim: int, global_struct_name: str
) -> Tuple[str, str]:
    target_var = "target"
    dims = "[ANY]" * ndim
    numpy_typemap = f"%apply ( {field_type} ARGOUT_ARRAY{ndim}{dims} ) {{ ({field_type} {target_var}{dims}) }};"
    accessor_func = f"""
    void get_{global_struct_name.strip("_")}_{field_name}({field_type} {target_var}{field_sizes})
    {{
        memcpy(
            {target_var},
            {global_struct_name}.{field_name},
            sizeof({global_struct_name}.{field_name})
        );
    }}
    """
    return numpy_typemap, "\n".join([line[4:] for line in accessor_func.splitlines()])


def generate_accessors(dst_bank_header: Path, interface_file: Path, doc_file: Path):
    source_code = dst_bank_header.read_text()
    space = r'\s*'
    struct_pattern_words = [
        r"typedef",
        r"struct",
        r"\{(?P<struct_body>.*)\}",
        r"(?P<struct_type>\w+)",
        r";.*",
        r"extern",
        r"(?P=struct_type)",
        r"(?P<struct_name>\w+)",
        r";",
    ]
    struct_pattern = space.join(struct_pattern_words)
    struct_match = re.search(struct_pattern, source_code, re.DOTALL)
    struct_type = struct_match.group('struct_type')
    global_struct_name = struct_match.group('struct_name')
    print(f"Generating numpy accessors for members of {struct_type} struct (global instance {global_struct_name})")

    # parsing struct body for array members
    struct_body = struct_match.group('struct_body')
    struct_body = re.sub(r"/\*.*?\*/", "", struct_body, flags=re.DOTALL)  # removing block comments
    struct_body = re.sub(r"//.*?$", "", struct_body, flags=re.MULTILINE)  # removing line comments
    statements = struct_body.split(";")
    statements = [s.strip() for s in statements]
    # ['integer4 event_num', 'integer4 event_code', 'integer4 site', ...]

    field_patt_words = [r"(?P<type>\w+)", r"(?P<name>\w+)", r"(?P<sizes>\[.+\])", r"$"]
    field_patt = space.join(field_patt_words)

    typemaps = set()
    funcs = []

    for statement in statements:
        field_match = re.match(field_patt, statement)
        if field_match is None:
            # non-array param
            continue
        field_type = field_match.group('type')
        field_name = field_match.group('name')
        field_sizes = field_match.group('sizes')
        ndim = len(re.findall(r"\[", field_sizes))
        print(f"{field_type} {field_name}{field_sizes};")
        typemap, acc_func = generate_accesor_func(field_type, field_name, field_sizes, ndim, global_struct_name)
        typemaps.add(typemap)
        funcs.append(acc_func)

    with open(interface_file, "w") as interface, open(doc_file, "a") as doc:
        interface.write(
            "// This file was generated by generate_numpy_accessors.py and provides accessor functions\n"
            + f"// to array fields of {global_struct_name} struct of type {struct_type}, defined in\n"
            + f"// {dst_bank_header}\n\n"
            + "// The structure body is:\n\n"
        )

        doc.write(f'\n    "{global_struct_name}": """\n')
        for line in struct_match.group('struct_body').splitlines():
            line = line.strip()
            if line:
                interface.write("// " + line + "\n")
                doc.write(line + "\n")
        doc.write(f'""",\n')

        interface.write("\n\n")
        for typemap in typemaps:
            interface.write(typemap + "\n")
        interface.write(r"%inline %{")
        for func in funcs:
            interface.write(func + "\n")
        interface.write(r"%}")


if __name__ == "__main__":
    # for testing purposes only
    parser = argparse.ArgumentParser()
    parser.add_argument("dst_bank_header_file")
    args = parser.parse_args()
    generate_accessors(Path(args.dst_bank_header_file), Path("test.i"))
